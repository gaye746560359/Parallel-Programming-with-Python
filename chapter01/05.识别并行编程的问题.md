&emsp;这里有一些勇敢键盘战士可以解决的并行编程的问题。很多这样的问题在没有经验的程序员使用共享状态的时候会出现。下面我来说说其中的一些。

#### 死锁

&emsp;所谓死锁，是指各并发进程彼此互相等待对方所拥有的资源，且这些病发进程在得到对方的资源之前不会释放自己所拥有的资源。从而造成大家都想得到资源而又得不到资源，各并发进程不能继续向前推进的状态。（摘自中山大学官网课件）[中山大学](http://ettc.sysu.edu.cn/2005wlkc/caozuoxitong/book/chapter4/lesson6/lesson6.htm)。在多任务系统下，当一个或多个进程等待系统资源，而资源又被进程本身或其它进程占用时，就形成了死锁。例如，一个进程 p1占用了显示器，同时又必须使用打印机，而打印机被进程p2占用，p2又必须使用显示器，这样就形成了死锁。使用有序资源分配法和银行家算法等是避免死锁的有效方法。我们也可以尝试回避死锁。因为在理论上，死锁总是可能产生的，所以操作系统尝试监视所有进程，使其没有死锁。最简单的消除死锁的办法是重启系统。更好的办法是终止一个进程的运行。


死锁产生的四个必要条件：

1. **互斥条件**: 并发进程所要求和占有的资源是不能同时被两个以上进程使用或操作的，进程对它所需要的资源进行排他性控制。
2. **不剥夺条件**: 进程所获得的资源在未使用完毕之前，不能被其它进程强行剥夺，而只能由获得该资源的进程自己释放。
3. **部分分配**: 进程每次申请它所需要的一部分资源，在等待新资源的同时，继续占用已分配的资源。
4. **环路条件**: 存在一种进程循环链，链中每一个进程已获得的资源同时被下一个进程所请求。

####饥饿/饿死

&emsp;产生饥饿的主要原因是：在一个动态系统中，对于每类系统资源，操作系统需要确定一个分配策略，当多个进程同时申请某类资源时，由分配策略确定资源分配给进程的次序。有时资源分配策略可能是不公平的，即不能保证等待时间上界的存在。在这种情况下，即使系统没有发生死锁，某些进程也可能会长时间等待。当等待时间给进程推进和响应带来明显影响时，称发生了进程“饥饿”，当“饥饿”到一定程度的进程所赋予的任务即使完成也不再具有实际意义时称该进程被“饿死”。

&emsp;例如，当有多个进程需要打印文件时，如果系统分配打印机的策略是最短文件优先，那么长文件的打印任务将由于短文件的源源不断到来而被无限期推迟，导致最终的“饥饿”甚至“饿死”,“饥饿”并不表示系统一定死锁，但至少有一个进程的执行被无限期推迟。

饥饿与死锁的主要差别有：

* 进入饥饿状态的进程可以只有一个，而由于循环等待条件而进入死锁状态的进程却必须大于或等于两个。
* 处于饥饿状态的进程可以是一个就绪进程，如静态优先权调度算法时的低优先权进程，而处于死锁状态的进程则必定是阻塞进程。

#### 竞态条件

当进程的结果依赖于一些事实的序列时，而这些序列由于缺少同步机制而被破坏，我们就会遇到竞态条件。在更大的系统里结果会更加难以确定。举个例子，一对夫妇有一个共有的账户，初始的余额是100。下面的表格显示了又保护机制正常显示的情况：

![1](https://raw.githubusercontent.com/hellorocky/techblog/master/picture/Presents%20baking%20operations%20without%20the%20chance%20of%20race%20conditions%20occurrence.png)

下面的表格显示了有问题的情景。假设这个账户没有同步机制操作顺序也没有按照预期。

![2](https://github.com/hellorocky/techblog/blob/master/picture/Analogy%20to%20balance%20the%20problem%20in%20a%20joint%20account%20and%20race%20conditions.png)

&emsp;由于操作顺序同步机制的缺少在最后的结果上产生了很明显的不一致。并行编程其中一个特点就是不确定性。预见在某一个时刻是哪一个`worker`在运行是不可能的，也不可能知道哪一个先运行。因此，同步机制是很重要的。

> 不确定性，如果同时缺少同步机制就会导致竞态条件


